# Sistema de Prompts Editables de IA

## ‚úÖ Implementaci√≥n Completa

Se ha implementado un sistema completo para gestionar prompts de IA sin modificar c√≥digo:

### üìã Componentes Creados

1. **Modelo de Base de Datos** (`schema.prisma`)
   - Tabla `ai_prompts` con soporte multi-tenant
   - Versionado autom√°tico
   - M√©tricas de uso (tasa de √©xito, veces usado)
   - Soporte para diferentes motores (OpenAI, Gemini, Claude, Ollama)

2. **Servicio PromptManager** (`services/promptManager.js`)
   - Cache en memoria (TTL: 5 minutos configurables)
   - Sistema de fallback (tenant ‚Üí global)
   - Reemplazo de variables `{{variable}}`
   - M√©tricas autom√°ticas de rendimiento

3. **API REST** (`routes/prompts.js`)
   - `GET /api/prompts` - Listar prompts
   - `POST /api/prompts` - Crear prompt
   - `PUT /api/prompts/:id` - Actualizar prompt
   - `DELETE /api/prompts/:id` - Eliminar prompt
   - `POST /api/prompts/test` - Probar prompt con variables
   - `GET /api/prompts/stats/cache` - Estad√≠sticas del cache
   - `POST /api/prompts/cache/clear` - Limpiar cache

4. **Seed de Prompts** (`prisma/seeds/prompts.js`)
   - Migraci√≥n autom√°tica de prompts hardcodeados
   - 5 prompts pre-configurados:
     - Extracci√≥n facturas (OpenAI, Claude, Gemini, Ollama)
     - Extracci√≥n res√∫menes de tarjeta

## üöÄ Pr√≥ximos Pasos

### 1. Aplicar Migraci√≥n de Prisma

```bash
cd backend
npx prisma migrate dev --name add_ai_prompts
npx prisma generate
```

### 2. Ejecutar Seed de Prompts

```bash
node prisma/seeds/prompts.js
```

### 3. Actualizar Funciones de Extracci√≥n

**YA ACTUALIZADO:** `extractWithOpenAI` ya usa PromptManager

**PENDIENTE - Actualizar estas funciones en `documentProcessor.js`:**

```javascript
// extractWithClaude (l√≠nea ~294)
async extractWithClaude(text, tenantId = null) {
  try {
    const Anthropic = require('@anthropic-ai/sdk');
    const anthropic = new Anthropic({
      apiKey: process.env.ANTHROPIC_API_KEY,
    });

    const prompt = await promptManager.getPromptText(
      'EXTRACCION_FACTURA_CLAUDE',
      { text },
      tenantId,
      'anthropic'
    );

    if (!prompt) {
      console.error('‚ùå Prompt EXTRACCION_FACTURA_CLAUDE no encontrado');
      return null;
    }

    const response = await anthropic.messages.create({
      model: 'claude-3-haiku-20240307',
      max_tokens: 300,
      messages: [{ role: 'user', content: prompt }],
    });

    const result = JSON.parse(response.content[0].text);
    await promptManager.registrarResultado('EXTRACCION_FACTURA_CLAUDE', true, tenantId);
    return result;
  } catch (error) {
    console.error('Error with Claude extraction:', error);
    await promptManager.registrarResultado('EXTRACCION_FACTURA_CLAUDE', false, tenantId).catch(() => {});
    return null;
  }
}

// extractWithGemini (l√≠nea ~402)
async extractWithGemini(text, tenantId = null, retries = 0) {
  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      const { GoogleGenerativeAI } = require('@google/generative-ai');
      const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
      const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });

      const prompt = await promptManager.getPromptText(
        'EXTRACCION_FACTURA_GEMINI',
        { text },
        tenantId,
        'gemini'
      );

      if (!prompt) {
        console.error('‚ùå Prompt EXTRACCION_FACTURA_GEMINI no encontrado');
        return null;
      }

      const result = await model.generateContent(prompt);
      let jsonText = result.response.text();

      // Limpiar respuesta (mantener l√≥gica existente)
      jsonText = jsonText
        .replace(/```json\n?/g, '')
        .replace(/\n?```/g, '')
        .replace(/^[^{]*{/, '{')
        .replace(/}[^}]*$/, '}')
        .replace(/\/\/.*$/gm, '')
        .replace(/\/\*[\s\S]*?\*\//g, '')
        .trim();

      const data = JSON.parse(jsonText);
      await promptManager.registrarResultado('EXTRACCION_FACTURA_GEMINI', true, tenantId);
      return data;

    } catch (error) {
      console.error(`Error with Gemini extraction (attempt ${attempt + 1}):`, error);

      if (error.status === 503 && attempt < retries) {
        const delay = Math.pow(2, attempt) * 1000;
        console.log(`Gemini service unavailable, retrying in ${delay}ms...`);
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }

      if (attempt === retries) {
        await promptManager.registrarResultado('EXTRACCION_FACTURA_GEMINI', false, tenantId).catch(() => {});
        return null;
      }
    }
  }
  return null;
}

// extractResumenTarjetaWithAI (l√≠nea ~1684)
async extractResumenTarjetaWithAI(text, tenantId = null) {
  try {
    const limitedText = text.substring(0, 10000);

    const prompt = await promptManager.getPromptText(
      'EXTRACCION_RESUMEN_TARJETA',
      { text: limitedText },
      tenantId
    );

    if (!prompt) {
      console.error('‚ùå Prompt EXTRACCION_RESUMEN_TARJETA no encontrado');
      return null;
    }

    // Intentar con Gemini primero
    if (process.env.GEMINI_API_KEY && process.env.GEMINI_API_KEY !== 'tu-api-key-aqui') {
      try {
        console.log('ü§ñ [RESUMEN TARJETA] Intentando con Gemini...');
        const { GoogleGenerativeAI } = require('@google/generative-ai');
        const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
        const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });

        const result = await model.generateContent(prompt);
        let jsonText = result.response.text();

        // Limpiar respuesta
        jsonText = jsonText
          .replace(/```json\n?/g, '')
          .replace(/\n?```/g, '')
          .replace(/^[^{]*{/, '{')
          .replace(/}[^}]*$/, '}')
          .replace(/\/\/.*$/gm, '')
          .replace(/\/\*[\s\S]*?\*\//g, '')
          .trim();

        const data = JSON.parse(jsonText);

        if (data.metadata && data.transacciones && Array.isArray(data.transacciones)) {
          await promptManager.registrarResultado('EXTRACCION_RESUMEN_TARJETA', true, tenantId);
          return data;
        }
      } catch (error) {
        console.error('‚ö†Ô∏è [RESUMEN TARJETA] Error con Gemini:', error.message);
      }
    }

    // Intentar con Anthropic como fallback
    if (process.env.ANTHROPIC_API_KEY && process.env.ANTHROPIC_API_KEY !== 'tu-api-key-aqui') {
      try {
        console.log('ü§ñ [RESUMEN TARJETA] Intentando con Anthropic...');
        const Anthropic = require('@anthropic-ai/sdk');
        const anthropic = new Anthropic({
          apiKey: process.env.ANTHROPIC_API_KEY,
        });

        const message = await anthropic.messages.create({
          model: 'claude-3-haiku-20240307',
          max_tokens: 2048,
          messages: [{
            role: 'user',
            content: prompt
          }]
        });

        const responseText = message.content[0].text;
        let jsonText = responseText;
        const jsonMatch = responseText.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          jsonText = jsonMatch[0];
        }

        const data = JSON.parse(jsonText);

        if (data.metadata && data.transacciones && Array.isArray(data.transacciones)) {
          await promptManager.registrarResultado('EXTRACCION_RESUMEN_TARJETA', true, tenantId);
          return data;
        }
      } catch (error) {
        console.error('‚ö†Ô∏è [RESUMEN TARJETA] Error con Anthropic:', error.message);
      }
    }

    await promptManager.registrarResultado('EXTRACCION_RESUMEN_TARJETA', false, tenantId);
    return null;

  } catch (error) {
    console.error('Error in extractResumenTarjetaWithAI:', error);
    await promptManager.registrarResultado('EXTRACCION_RESUMEN_TARJETA', false, tenantId).catch(() => {});
    return null;
  }
}
```

### 4. Pasar tenantId a las Funciones de Extracci√≥n

En los lugares donde se llama a las funciones de extracci√≥n (ej: `routes/documentos.js`), pasar el `tenantId`:

```javascript
// Antes
const data = await processor.extractWithGemini(text);

// Despu√©s
const data = await processor.extractWithGemini(text, req.tenantId);
```

## üìä Uso del Sistema

### API Ejemplos

#### Listar Prompts
```bash
curl http://localhost:5050/api/prompts \
  -H "Authorization: Bearer TOKEN"
```

#### Crear Prompt Personalizado (por tenant)
```bash
curl -X POST http://localhost:5050/api/prompts \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer TOKEN" \
  -d '{
    "clave": "EXTRACCION_FACTURA_GEMINI",
    "nombre": "Extracci√≥n Personalizada Tenant X",
    "prompt": "Mi prompt personalizado con {{text}}",
    "descripcion": "Versi√≥n customizada para mi empresa",
    "motor": "gemini",
    "variables": {
      "text": "Texto del documento"
    }
  }'
```

#### Probar Prompt
```bash
curl -X POST http://localhost:5050/api/prompts/test \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer TOKEN" \
  -d '{
    "clave": "EXTRACCION_FACTURA_GEMINI",
    "variables": {
      "text": "Texto de prueba..."
    },
    "motor": "gemini"
  }'
```

#### Ver Estad√≠sticas del Cache
```bash
curl http://localhost:5050/api/prompts/stats/cache \
  -H "Authorization: Bearer TOKEN"
```

## üéØ Beneficios

1. **Sin Modificar C√≥digo**: Prompts editables desde API/UI
2. **Multi-tenant**: Cada cliente puede tener sus propios prompts
3. **Versionado**: Historial autom√°tico de cambios
4. **Performance**: Cache en memoria con TTL configurable
5. **M√©tricas**: Tasa de √©xito autom√°tica
6. **Fallback**: Sistema de tenant ‚Üí global
7. **Variables**: Reemplazo din√°mico tipo `{{variable}}`

## üîß Variables de Entorno

```env
# Cache de prompts (opcional)
PROMPT_CACHE_TTL=300000  # 5 minutos en ms (default)
```

## üìù Variables Disponibles en Prompts

- `{{text}}` - Texto completo del documento
- (Puedes agregar m√°s seg√∫n necesites)

## üöÄ UI Futura (Recomendado)

Crear en el frontend:
- P√°gina `/admin/prompts` con lista de prompts
- Editor de prompts con preview
- Selector de motor de IA
- Comparaci√≥n de versiones
- M√©tricas visuales (gr√°ficos de tasa de √©xito)
- Test en tiempo real

## ‚ú® Estructura Final

```
backend/
‚îú‚îÄ‚îÄ prisma/
‚îÇ   ‚îú‚îÄ‚îÄ schema.prisma         # ‚úÖ Modelo ai_prompts agregado
‚îÇ   ‚îî‚îÄ‚îÄ seeds/
‚îÇ       ‚îî‚îÄ‚îÄ prompts.js         # ‚úÖ Seed de prompts
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ promptManager.js   # ‚úÖ Gestor con cache
‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ prompts.js         # ‚úÖ API REST
‚îÇ   ‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ documentProcessor.js # üîÑ Actualizar funciones restantes
‚îÇ   ‚îî‚îÄ‚îÄ index.js               # ‚úÖ Rutas registradas
```

## üéâ ¬°Listo!

El sistema est√° funcionalmente completo. Solo falta:
1. Aplicar migraci√≥n
2. Ejecutar seed
3. Actualizar las funciones restantes de documentProcessor.js
4. (Opcional) Crear UI de administraci√≥n
